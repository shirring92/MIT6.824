README

This lab is the second part of building a fault-tolerant key/value storage service. This lab use raft library from lab2. The key/value service is a replicated state machine, consisting of several key/value servers that use Raft for replication. The key/value service should continue to process client requests as long as majority of the servers are alive and can communicate, in spite of other failures or network partitions.

The service support three operations: Put(key, value), Append(key, value), and Get(key). It maintains a simple database of key/value pairs. Keys and values are strings. Put() replaces the value for a particular key in the database, Append(key, arg) appends arg to key's value, and Get() fetches the current value for a key. A Get for a non-existant key should return an empty string. An Append to a non-existant key should act like Put. Each client talks to the service through a Clerk with Put/Append/Get methods. A Clerk manages RPC interactions with the servers.

The service provide strong consistency to application calls to the Clerk Get/Put/Append methods. If called one at a time, the Get/Put/Append methods should act as if the system had only one copy of its state, and each call should observe the modifications to the state implied by the preceding sequence of calls. For concurrent calls, the return values and final state must be the same as if the operations had executed one at a time in some order. Calls are concurrent if they overlap in time, for example if client X calls Clerk.Put(), then client Y calls Clerk.Append(), and then client X's call returns. Futhermore, a call must observe the effects of all calls that have completed before the call starts (linearizability).

Strong consistency is convenient for applications because it means that all clients see the same state and they all see the latest state. Providing strong consistency is relatively easy for a single server. It is harder if the service is replicated, since all servers must choose the same execution order for concurrent requests, and must avoid replying to clients using state that isn't up to date.

This lab also implements the snapshots service which allow Raft to discard old log entries to avoid Raft log growing without bound.